<!-- engineer_week_fusion.html / 2048 + 六角堆疊挑戰版 -->
<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Engineer Week｜2048 + 六角堆疊挑戰</title>
  <!-- TailwindCSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- React + ReactDOM -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <!-- Babel for JSX -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <!-- Supabase -->
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/dist/umd/supabase.min.js"></script>
  <style>
    html,body{background:#000;}
    canvas{touch-action:none;}
  </style>
</head>
<body class="bg-black text-white">
<div id="root"></div>

<script type="text/babel">
const { useState, useEffect, useRef, useMemo } = React;

// Supabase Config
const SUPABASE_URL = "https://iudtlababxabhlxstfry.supabase.co";
const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Iml1ZHRsYWJhYnhhYmhseHN0ZnJ5Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjE3OTQwMzIsImV4cCI6MjA3NzM3MDAzMn0.ly_s5nLCXBvFM7DToOaAI9Ip0v4MGqxamTGqAxpDsko";
const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

const nowTS = ()=>new Date().toISOString();
const PLANTS = ["南科","中科","龍潭","竹科","台中","其他"];

async function sbFetchLeaderboard(mode){
  try{
    const {data,error}=await supabase.from("scores")
      .select("*")
      .eq("mode",mode)
      .order("score",{ascending:false})
      .limit(100);
    if(error)throw error;
    return data||[];
  }catch(e){console.warn("fetch fail",e);return [];}
}
async function sbSubmitScore(entry){
  try{
    const {created_at:_omit,...ins}=entry;
    const {error}=await supabase.from("scores").insert([ins]);
    if(error)throw error;
    return {ok:true};
  }catch(e){return {ok:false,error:e.message||String(e)};}
}

/* ========== Game 2048 ========== */
function Game2048({onFinish}){
  const SIZE=4;
  const [b,setB]=useState(Array(16).fill(0));
  const [score,setScore]=useState(0);
  const [moves,setMoves]=useState(0);
  const [over,setOver]=useState(false);
  const boardRef=useRef(null);

  const idx=(r,c)=>r*SIZE+c;
  const spawn=(bb)=>{
    const e=bb.map((v,i)=>v===0?i:-1).filter(i=>i>=0);
    if(!e.length)return bb;
    const pos=e[Math.floor(Math.random()*e.length)];
    const val=Math.random()<0.9?2:4;
    const nb=[...bb];nb[pos]=val;return nb;
  };
  const slide=(arr)=>{
    const n=arr.filter(v=>v!==0);const out=[];let gain=0;
    for(let i=0;i<n.length;i++){
      if(i<n.length-1&&n[i]===n[i+1]){out.push(n[i]*2);gain+=n[i]*2;i++;}
      else out.push(n[i]);
    }
    while(out.length<SIZE)out.push(0);
    return {row:out,gain};
  };
  const rotate=(bb)=>{const nb=Array(16).fill(0);
    for(let r=0;r<4;r++)for(let c=0;c<4;c++)nb[idx(c,3-r)]=bb[idx(r,c)];
    return nb;
  };
  const canMove=(bb)=>{
    if(bb.some(v=>v===0))return true;
    for(let r=0;r<4;r++)for(let c=0;c<4;c++){
      const v=bb[idx(r,c)];
      if(r+1<4&&bb[idx(r+1,c)]===v)return true;
      if(c+1<4&&bb[idx(r,c+1)]===v)return true;
    }
    return false;
  };
  const moveLeft=(bb)=>{
    let g=0;const nb=[...bb];
    for(let r=0;r<4;r++){
      const row=[0,1,2,3].map(c=>nb[idx(r,c)]);
      const {row:s,gain}=slide(row);g+=gain;
      for(let c=0;c<4;c++)nb[idx(r,c)]=s[c];
    }
    return {nb,g};
  };
  const move=(dir)=>{
    if(over)return;
    let bb=[...b];let rot=0;
    if(dir==="ArrowUp")rot=1;if(dir==="ArrowRight")rot=2;if(dir==="ArrowDown")rot=3;
    for(let i=0;i<rot;i++)bb=rotate(bb);
    const {nb,g}=moveLeft(bb);let back=nb;
    for(let i=0;i<(4-rot)%4;i++)back=rotate(back);
    if(back.join(",")!==b.join(",")){
      back=spawn(back);
      setB(back);setScore(s=>s+g);setMoves(m=>m+1);
      if(!canMove(back))setOver(true);
    }
  };
  useEffect(()=>{
    let bb=Array(16).fill(0);bb=spawn(spawn(bb));setB(bb);
  },[]);
  const onKey=e=>{
    if(["ArrowLeft","ArrowRight","ArrowUp","ArrowDown"].includes(e.key)){
      e.preventDefault();move(e.key);
    }
  };
  const submit=()=>onFinish({
    mode:"2048",
    modeLabel:"2048",
    target:0,
    elapsed:moves,
    score,
    created_at:nowTS()
  });
  return (
    <div onKeyDown={onKey} tabIndex={0} ref={boardRef} className="outline-none select-none">
      <div className="flex justify-between mb-2">
        <div>分數：{score} 步數：{moves}</div>
        <button onClick={submit} className="bg-blue-500 px-3 py-1 rounded text-sm">上傳分數</button>
      </div>
      <div className="grid grid-cols-4 gap-2 bg-neutral-800 p-3 rounded-2xl">
        {b.map((v,i)=><div key={i} className={"aspect-square flex items-center justify-center rounded-xl font-bold text-2xl "+(v? "bg-yellow-300 text-black":"bg-neutral-900 text-neutral-700")}>{v||""}</div>)}
      </div>
      {over && <p className="text-center text-red-400 mt-2">遊戲結束</p>}
    </div>
  );
}

/* ========== Hextris-lite ========== */
function Hextris({onFinish}){
  const ref=useRef();
  const [score,setScore]=useState(0);
  const [level,setLevel]=useState(1);
  const [over,setOver]=useState(false);
  useEffect(()=>{
    const canvas=ref.current,ctx=canvas.getContext("2d");
    let angle=0,stack=[[],[],[],[],[],[]],blocks=[],t=0,last=0,gameOver=false;
    function drawHex(cx,cy,r,rot,col){
      ctx.save();ctx.translate(cx,cy);ctx.rotate(rot);
      ctx.beginPath();for(let i=0;i<6;i++){const a=Math.PI/3*i;const x=r*Math.cos(a),y=r*Math.sin(a);i?ctx.lineTo(x,y):ctx.moveTo(x,y);}
      ctx.closePath();ctx.strokeStyle=col;ctx.lineWidth=2;ctx.stroke();ctx.restore();
    }
    function sidePos(cx,cy,r,i,rot){const a=rot+i*Math.PI/3;return{x:cx+(r-10)*Math.cos(a),y:cy+(r-10)*Math.sin(a)};}
    function spawn(){blocks.push({side:Math.floor(Math.random()*6),y:-30,color:`hsl(${Math.random()*360} 70% 60%)`});}
    function update(dt){
      if(gameOver)return;
      t+=dt;if(t>700/Math.sqrt(level)){t=0;spawn();}
      for(const b of blocks)b.y+=dt*0.15*level;
      const newBlocks=[];for(const b of blocks){
        if(b.y>=200){
          stack[b.side].push(b.color);
          setScore(s=>s+10*level);
          if(stack[b.side].length>=10)gameOver=true;
        }else newBlocks.push(b);
      }
      blocks=newBlocks;
      let minH=Math.min(...stack.map(s=>s.length));
      if(minH>0){for(const s of stack)s.shift();setScore(s=>s+100*level);setLevel(l=>l+1);}
    }
    function draw(){
      const w=canvas.width,h=canvas.height,cx=w/2,cy=h/2;
      ctx.clearRect(0,0,w,h);
      drawHex(cx,cy,120,angle,"#334");
      drawHex(cx,cy,160,angle,"#556");
      for(let i=0;i<6;i++){
        const c=sidePos(cx,cy,120,i,angle);
        const st=stack[i];
        for(let j=0;j<st.length;j++){
          ctx.save();ctx.translate(c.x,c.y-j*10);ctx.rotate(angle+i*Math.PI/3);
          ctx.fillStyle=st[j];ctx.fillRect(-10,-10,20,10);ctx.restore();
        }
      }
      for(const b of blocks){
        const c=sidePos(cx,cy,160,b.side,angle);
        ctx.save();ctx.translate(c.x,c.y-b.y);ctx.rotate(angle+b.side*Math.PI/3);
        ctx.fillStyle=b.color;ctx.fillRect(-10,-10,20,10);ctx.restore();
      }
      if(gameOver){ctx.fillStyle="rgba(0,0,0,.6)";ctx.fillRect(0,0,w,h);
        ctx.fillStyle="#fff";ctx.font="24px sans-serif";ctx.textAlign="center";
        ctx.fillText("遊戲結束",cx,cy);
      }
    }
    function loop(ts){const dt=ts-last;last=ts;update(dt);draw();if(!gameOver)requestAnimationFrame(loop);}
    requestAnimationFrame(loop);
    function turn(d){angle+=d*0.2;}
    const key=e=>{if(e.key==="ArrowLeft"||e.key==="a")turn(-1);if(e.key==="ArrowRight"||e.key==="d")turn(1);};
    window.addEventListener("keydown",key);
    return()=>{window.removeEventListener("keydown",key);}
  },[]);
  const submit=()=>onFinish({mode:"HEXTRIS",modeLabel:"六角堆疊挑戰",target:0,elapsed:level,score,created_at:nowTS()});
  return (
    <div>
      <div className="flex justify-between mb-2">
        <div>分數：{score} 等級：{level}</div>
        <button onClick={submit} className="bg-blue-500 px-3 py-1 rounded text-sm">上傳分數</button>
      </div>
      <canvas ref={ref} width="300" height="300" className="bg-neutral-900 rounded-2xl mx-auto"></canvas>
    </div>
  );
}

/* ========== Leaderboard ========== */
function Leaderboard({data,title}){
  return (
    <div className="mt-4">
      <h3 className="font-bold mb-2">{title}</h3>
      <table className="w-full text-sm">
        <thead><tr className="text-slate-400 text-xs"><th className="text-left p-1">#</th><th className="text-left p-1">暱稱</th><th className="text-left p-1">廠區</th><th className="text-left p-1">分數</th><th className="text-left p-1">步數/等級</th><th className="text-left p-1">時間</th></tr></thead>
        <tbody>
          {data.map((r,i)=><tr key={r.id} className={i%2?"bg-neutral-900":"bg-neutral-800"}>
            <td className="p-1">{i+1}</td>
            <td className="p-1">{r.name}</td>
            <td className="p-1">{r.plant}</td>
            <td className="p-1 text-yellow-300">{r.score}</td>
            <td className="p-1">{r.elapsed}</td>
            <td className="p-1 text-xs text-slate-400">{new Date(r.created_at).toLocaleString()}</td>
          </tr>)}
          {data.length===0&&<tr><td colSpan="6" className="text-center text-slate-500 p-2">尚無資料</td></tr>}
        </tbody>
      </table>
    </div>
  );
}

/* ========== Main App ========== */
function App(){
  const [mode,setMode]=useState("2048");
  const [name,setName]=useState("");
  const [plant,setPlant]=useState(PLANTS[0]);
  const [dept,setDept]=useState("");
  const [lb2048,setLb2048]=useState([]);
  const [lbHex,setLbHex]=useState([]);
  const refresh=async()=>{
    setLb2048(await sbFetchLeaderboard("2048"));
    setLbHex(await sbFetchLeaderboard("HEXTRIS"));
  };
  useEffect(()=>{
    refresh();
    const ch=supabase.channel("scores").on("postgres_changes",{event:"*",schema:"public",table:"scores"},refresh).subscribe();
    return()=>supabase.removeChannel(ch);
  },[]);
  const submitScore=async(e)=>{
    if(!name.trim()){alert("請輸入暱稱");return;}
    const entry={id:crypto.randomUUID(),name,plant,dept,...e};
    const {ok,error}=await sbSubmitScore(entry);
    if(ok){alert("上傳成功");refresh();}else alert("上傳失敗："+error);
  };
  return (
    <div className="max-w-6xl mx-auto p-4">
      <h1 className="text-xl font-bold mb-3">Engineer Week｜2048 + 六角堆疊挑戰</h1>
      <div className="flex flex-wrap gap-3 mb-4">
        <button onClick={()=>setMode("2048")} className={"px-3 py-2 rounded "+(mode==="2048"?"bg-yellow-400 text-black":"bg-neutral-800")}>2048</button>
        <button onClick={()=>setMode("HEXTRIS")} className={"px-3 py-2 rounded "+(mode==="HEXTRIS"?"bg-yellow-400 text-black":"bg-neutral-800")}>六角堆疊挑戰</button>
      </div>

      <div className="grid md:grid-cols-2 gap-6">
        <div className="border border-white/10 p-4 rounded-2xl bg-black/40">
          {mode==="2048"?<Game2048 onFinish={submitScore}/>:<Hextris onFinish={submitScore}/>}
        </div>

        <div className="space-y-3">
          <div className="border border-white/10 p-4 rounded-2xl bg-black/40">
            <h2 className="font-bold mb-2">👤 參賽者資訊</h2>
            <input value={name} onChange={e=>setName(e.target.value)} placeholder="暱稱" className="w-full mb-2 bg-neutral-900 rounded p-2"/>
            <select value={plant} onChange={e=>setPlant(e.target.value)} className="w-full mb-2 bg-neutral-900 rounded p-2">{PLANTS.map(p=><option key={p}>{p}</option>)}</select>
            <input value={dept} onChange={e=>setDept(e.target.value)} placeholder="部門（選填）" className="w-full bg-neutral-900 rounded p-2"/>
          </div>
          <div className="border border-white/10 p-4 rounded-2xl bg-black/40">
            <Leaderboard data={lb2048} title="🏆 2048 排行榜"/>
            <Leaderboard data={lbHex} title="🏆 六角堆疊挑戰 排行榜"/>
          </div>
        </div>
      </div>
    </div>
  );
}

ReactDOM.createRoot(document.getElementById("root")).render(<App/>);
</script>
</body>
</html>
